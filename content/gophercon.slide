Go for Decimals
Tags: decimal, floating point, fixed precision, IEEE 754R

Joshua Carpeggiani
Software Engineer, ANZ
joshua.carpeggiani@anz.com
: Software engineer working with go for about a year; decimal project, go-course

* 
"If I had a dime for every time I've seen someone use FLOAT to store currency, I'd have $999.997634." - Bill Karwin

* Floating point numbers
.play ../examples/floatExample.go /^func main/,/^}/

* Floating point numbers
.play ../examples/TimeRounding.go /^func main/,/^}/

* Floating point numbers
.play ../examples/floats/floatRound.go /^func main/,/^}/

* Floating point numbers
- not even deterministic across architectures:
    int main(void) {
        long double a = 1.0; 
        long double b = 3.0; 
        double f = (a / b) - (1.0/3.0);
        printf("%.50f\n", f);
    }

 
 
    x86 result: 0.33333333333333333334236835143737920361672877334058

    arm result: 0.33333333333333331482961625624739099293947219848633

* Floating point numbers
.image img/oddVsEven.png 550 _

* Floating point numbers
.play ../examples/floats/floatAdd.go /^func main/,/^}/

* Scientific notation

.html html/basic.html
: Scientific notation is at the base of what a floating point number is;
: We can take out number, pick-up the decimal point and move it to wherever we want
: Then when we're representing the number, we multiply it by 10 to the power
: of the amount of decimal shifts we moved our point

: Ths allows us to store really really large numbers and also really really small numbers
: without having to fill up our screen with zeros


* Binary floating point numbers
.html html/basicBinary.html

: The same can be done with binary numbers
: note instead of a 10 we now have a 2 as the base, because we're counting in base 2


* Floating point numbers
.html html/basicBinary.html

.html html/floatingpointbits.html
: And now arises the question of how to represent this in a bunch of bits?
: We can divide up just a standard 32 bit integer into the sign exponent and significand 
: but there's a problem: we can't represent decimal fractions 

* The problem with floating point numbers
Repeated decimal numbers:
.html html/110.html
Repeated binary numbers:
.html html/decFrac.html

* Why?
.html html/Sheet2.html

* Why?
.image img/BinDec.png _ 500

* Solution - Decimal datatype

.html html/110decimal.html

* Bit representation of IEEE 754-2008 decimal floating point
.html html/floatingpointbits.html
.html html/decimalpointbits.html

* Solution - Decimal datatype
.play ../examples/decimal/decimalExample.go /^func main/,/^}/
Base 10 counting system instead of base 2

* Usage of decimal libraries
.image img/decimalSurvey.png 600 _

* Requirements of a number library: Binary floats
1. Accuracy ✘
2. Portability ?
3. Speed ?

* Portability and Speed

* 1980
.image img/8087.jpg 200 _
- Intel 8087 released
- FPU; "Floating Point Unit"
- Used to speed up calculations via hardware implementations
: C released 8 years previously and didn;t have a builtin float type

* 1980
.image img/8087_inside.jpg 600 _

* 1980
.image img/8087_schematic.png 500 _


* 1985
- IEEE 754 standard:
- Standardised floating point implementations across platforms
- Implemented into almost every programming language and has hardware support on majorty of cpu architectures
* IEEE 754 standard:
- 5 Rounding attributes
- +- inf
- -0 == +0
- 1/0 == +inf
- 0/0 == NaN

* Benchmarking
.image img/Add_new.png 500 _

* Binary floating point Add
    func Add(x, y float64) float64 {
            return x + y
        }

* Binary floating point Assembler
    func Add(x, y float64) float64 {
        return x + y
    }
 
    "".Add STEXT nosplit size=23 args=0x18 locals=0x0
    TEXT	"".Add(SB), NOSPLIT|ABIInternal, $0-24
    FUNCDATA	$0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
    FUNCDATA	$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
    FUNCDATA	$3, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
    PCDATA	$2, $0
    PCDATA	$0, $0
    MOVSD	"".x+8(SP), X0
    MOVSD	"".y+16(SP), X1
    ADDSD	X1, X0
    MOVSD	X0, "".~r2+24(SP)
    RET

* ADDSD
"Add Scalar Double-Precision Floating-Point Values"

* Requirements of a number library: Binary floats
1. Accuracy ✘
2. Portability ✓
3. Speed ✓

* A new decimal library in go
- Follows 2008-r standard
- Allows for future hardware support and optimisations

* Arithmetic benchmarks - Add
.image img/Add_dec.png 500 _


* Binary floating point Assembler
    func Add(x, y float64) float64 {
        return x + y
    }
 
    "".Add STEXT nosplit size=23 args=0x18 locals=0x0
    TEXT    "".Add(SB), NOSPLIT|ABIInternal, $0-24
    FUNCDATA    $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
    FUNCDATA    $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
    FUNCDATA    $3, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
    PCDATA    $2, $0
    PCDATA    $0, $0
    MOVSD    "".x+8(SP), X0
    MOVSD    "".y+16(SP), X1
    ADDSD    X1, X0
    MOVSD    X0, "".~r2+24(SP)
    RET

* Decimal Arithmetic in Go
    func (d Decimal64) Add(e Decimal64) Decimal64 {
        dp := d.getParts()
        ep := e.getParts()
        if dec := propagateNan(&dp, &ep); dec != nil {
            return *dec
        }
        if dp.fl == flInf || ep.fl == flInf {
            // Check infinities
        }
        // ...
        // Match scales
        var rndStatus discardedDigit
        dp.matchScales128(&ep)
        ans := dp.add128(&ep)
        rndStatus = ans.roundToLo()
        if ans.exp < -expOffset {
            rndStatus = ans.rescale(-expOffset)
        }
        // Do the calculation ...
        ans.significand.lo = ctx.roundingMode.round(ans.significand.lo, rndStatus)
        if ans.exp >= -expOffset && ans.significand.lo != 0 {
            ans.exp, ans.significand.lo = renormalize(ans.exp, ans.significand.lo)
        }
        if ans.exp > expMax || ans.significand.lo > maxSig {
            return infinities[ans.sign]
        }
        return newFromParts(ans.sign, ans.exp, ans.significand.lo)
    }

* Decimal Arithmetic in Assembler
.code ../examples/AddDec.asm

* Decimal Arithmetic in Assembler
.code ../examples/AddDec.asm  /^// PT 2/,/// PT 3/

* Decimal Arithmetic in Assembler
.code ../examples/AddDec.asm  /^// PT 3/,

* Requirements of a number library: Decimal floats
1. Accuracy ✓
2. Portability ✓
3. Speed ✗ (not yet)

* Looking forward
- More optimisation
- Implement 128 and 64 bit
- Assembler optimisations

* Links

- Benchmarking
.link https://github.com/joshcarp/decimal-slides
- Github
.link https://github.com/anz-bank/decimal

- Survey from reddit user kardianos
