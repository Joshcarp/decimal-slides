Go for Decimals
Tags: decimal, floating point, fixed precision, IEEE 754R

Joshua Carpeggiani
Software Engineer, ANZ
joshua.carpeggiani@anz.com
: Software engineer working with go for about a year; decimal project, go-course

* 
.image img/twitter.png 500 _
* Floating point numbers
.play ../examples/floatExample.go /^func main/,/^}/


* Floating point numbers
.play ../examples/floats/floatRound.go /^func main/,/^}/

* Floating point numbers
.play ../examples/floats/floatAdd.go /^func main/,/^}/

: This is the problem that we've learnt to live with
: Floats are inaccurate
: This is the problem I want to show alternatives for


: And to fix this, we need to go back a little bit to school; 

* Scientific notation

.html html/basic.html
: Scientific notation is at the base of what a floating point number is;
: We can take out number, pick-up the decimal point and move it to wherever we want
: Then when we're representing the number, we multiply it by 10 to the power
: of the amount of decimal shifts we moved our point

: Ths allows us to store really really large numbers and also really really small numbers
: without having to fill up our screen with zeros


* Binary floating point numbers
.html html/basicBinary.html

: The same can be done with binary numbers
: note instead of a 10 we now have a 2 as the base, because we're counting in base 2


* Floating point numbers
.html html/basicBinary.html

.html html/floatingpointbits.html
: And now arises the question of how to represent this in a bunch of bits?
: We can divide up just a standard 32 bit integer into the sign exponent and significand 
: but there's a problem: we can't represent decimal fractions 

* The problem with floating point numbers
Repeated decimal numbers:
.html html/110.html
Repeated binary numbers:
.html html/decFrac.html

* Why?
.html html/Sheet2.html

* Why?
.image img/BinDec.png _ 500

* When does this matter?

- Compounding errors
- Need for exact numbers

.play ../examples/TimeRounding.go /^func main/,/^}/


* Go Basic types

	bool

	string

	int  int8  int16  int32  int64
	uint uint8 uint16 uint32 uint64 uintptr

	byte // alias for uint8

	rune // alias for int32
	     // represents a Unicode code point

	float32 float64

	complex64 complex128



* Usage of decimal libraries
.image img/decimalSurvey.png 600 _

* Requirements of a number library: Binary floats
1. Accuracy ✘
2. Portability ?
3. Speed ?

* Solution - Decimal datatype

.html html/110decimal.html

.code ../examples/decimalExample.go /^func main/,/^}/
Base 10 counting system instead of base 2

* Bit representation of IEEE 754-2008 decimal floating point
.html html/floatingpointbits.html
.html html/decimalpointbits.html

* Usage of decimal libraries
.image img/decimalSurvey.png 600 _

* Existing Go decimal datatypes
.link https://github.com/ericlagergren/decimal/ github.com/ericlagergren/decimal
.link https://github.com/shopspring/decimal github.com/shopspring/decimal
shopspring seems to be unsupported; last commit was June 2018



* Portability and Speed

* 1980
.image img/8087.jpg 200 _
- Intel 8087 released
- FPU; "Floating Point Unit"
- Used to speed up calculations via hardware implementations
: C released 8 years previously and didn;t have a builtin float type

* 1980
.image img/8087_inside.jpg 600 _

* 1980
.image img/8087_schematic.png 500 _


* 1985
- IEEE 754 standard:
- Standardised floating point implementations across platforms
- Implemented into almost every programming language and has hardware support on majorty of cpu architectures
* IEEE 754 standard:
- 5 Rounding attributes
- +- inf
- -0 == +0
- 1/0 == +inf
- 0/0 == NaN

* Binary floating point Add
    func Add(x, y float64) float64 {
            return x + y
        }

* Binary floating point Assembler
    func Add(x, y float64) float64 {
        return x + y
    }
 
    "".Add STEXT nosplit size=23 args=0x18 locals=0x0
    TEXT	"".Add(SB), NOSPLIT|ABIInternal, $0-24
    FUNCDATA	$0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
    FUNCDATA	$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
    FUNCDATA	$3, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
    PCDATA	$2, $0
    PCDATA	$0, $0
    MOVSD	"".x+8(SP), X0
    MOVSD	"".y+16(SP), X1
    ADDSD	X1, X0
    MOVSD	X0, "".~r2+24(SP)
    RET

* ADDSD
"Add Scalar Double-Precision Floating-Point Values"

* Requirements of a number library: Binary floats
1. Accuracy ✘
2. Portability ✓
3. Speed ✓

* Requirements of a number library: Binary floats
1. Accuracy ✘
2. Portability ✓
3. Speed ✓
(Portability and Speed kinda come together)


* A new decimal library in go
- Follows 2008-r standard
- Allows for future hardware support and optimisations

* Benchmarking
Testing
- IBM test suite online with _81,300_ test cases
.link http://speleotrove.com/decimal/
Note: these benchmarks are testing edgecases

* Benchmarking

- float64
- anz-bank/decimal
- shopspring/decimal
- ericlagergren/decimal
Benchmarks are located at
.link https://github.com/joshcarp/decimal-slides

* Arithmetic benchmarks - Add
.image img/Add_5.png 500 _


* Binary floating point Assembler
    func Add(x, y float64) float64 {
        return x + y
    }
 
    "".Add STEXT nosplit size=23 args=0x18 locals=0x0
    TEXT    "".Add(SB), NOSPLIT|ABIInternal, $0-24
    FUNCDATA    $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
    FUNCDATA    $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
    FUNCDATA    $3, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
    PCDATA    $2, $0
    PCDATA    $0, $0
    MOVSD    "".x+8(SP), X0
    MOVSD    "".y+16(SP), X1
    ADDSD    X1, X0
    MOVSD    X0, "".~r2+24(SP)
    RET

* Decimal Arithmetic in Go
    func (d Decimal64) Add(e Decimal64) Decimal64 {
        dp := d.getParts()
        ep := e.getParts()
        if dec := propagateNan(&dp, &ep); dec != nil {
            return *dec
        }
        if dp.fl == flInf || ep.fl == flInf {
            // Check infinities
        }
        // ...
        // Match scales
        var rndStatus discardedDigit
        dp.matchScales128(&ep)
        ans := dp.add128(&ep)
        rndStatus = ans.roundToLo()
        if ans.exp < -expOffset {
            rndStatus = ans.rescale(-expOffset)
        }
        // Do the calculation ...
        ans.significand.lo = ctx.roundingMode.round(ans.significand.lo, rndStatus)
        if ans.exp >= -expOffset && ans.significand.lo != 0 {
            ans.exp, ans.significand.lo = renormalize(ans.exp, ans.significand.lo)
        }
        if ans.exp > expMax || ans.significand.lo > maxSig {
            return infinities[ans.sign]
        }
        return newFromParts(ans.sign, ans.exp, ans.significand.lo)
    }

* Decimal Arithmetic in Assembler
.code ../examples/AddDec.asm

* Decimal Arithmetic in Assembler
.code ../examples/AddDec.asm  /^// PT 2/,/// PT 3/

* Decimal Arithmetic in Assembler
.code ../examples/AddDec.asm  /^// PT 3/,

* Requirements of a number library: Decimal floats
1. Accuracy ✓
2. Portability ✓
3. Speed ✗ (not yet)

* IEEE 754
idea
* Looking forward
- More optimisation
- Implement 128 and 64 bit
- Assembler optimisations

* Links

- Benchmarking
.link https://github.com/joshcarp/decimal-slides
- Github
.link https://github.com/anz-bank/decimal

- Survey from reddit user kardianos
