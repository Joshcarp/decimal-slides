Go for Decimals
Tags: decimal, floating point, fixed precision, IEEE 754R

Joshua Carpeggiani
Software Engineer, ANZ
joshua.carpeggiani@anz.com

* 
.image img/Patriot_missile.jpg

* Go for decimals
Joshua Carpeggiani

* Floating point numbers
.image code/first_example.png 350 _


* Floating point numbers
.image code/first_example.png 350 _

.image code/first_ans.png _ 500



* Floating point numbers
.image code/second.png 400 _


* Floating point numbers
.image code/second.png 400 _
.image code/second_ans.png _ 500

* Not all numbering systems are created equal

* Binary 
.html html/binary_counting/1.html
.html html/binary_counting/2.html

* Binary 
.html html/binary_counting/1.html
.html html/binary_counting/2.html
.html html/binary_counting/3.html

* Binary 
.html html/binary_counting/1.html
.html html/binary_counting/2.html
.html html/binary_counting/3.html
.html html/binary_counting/4.html

* Binary 
.html html/binary_counting/1.html
.html html/binary_counting/2.html
.html html/binary_counting/3.html
.html html/binary_counting/4.html

* Binary 
.html html/binary_counting/1.html
.html html/binary_counting/5.html


* Binary 
.html html/binary_counting/1.html
.html html/binary_counting/5.html
.html html/binary_counting/6.html


* Binary 
.html html/binary_counting/1.html
.html html/binary_counting/5.html
.html html/binary_counting/6.html
.html html/binary_counting/7.html

* Binary floating point numbers
.html html/1e-2.html

* Binary 
.html html/binary_counting/1.html
.html html/binary_counting/11_1.html

* Binary 
.html html/binary_counting/1.html
.html html/binary_counting/11.html

* Binary 
.html html/binary_counting/1.html
.html html/binary_counting/12.html

* Binary 
.html html/binary_counting/1.html
.html html/binary_counting/14.html


* Why?
.image img/BinDec.png _ 500

* Another Decimal library
.link http://www.github.com/anz-bank/decimal

- Project Goal: Implement a 64 & 128 bit decimal floating point library
- Conform as closely to IEEE 754-2008 standard as practical


* Scientific notation

.html html/basic.html

* Scientific notation

.html html/basicAddition.html


* Another Decimal library
.image code/decimal_example.png 345 _


* Another Decimal library
.image code/decimal_example.png 345 _

.image code/decimal_ans.png 175 _


* Telephone company
.image code/telephone_dec.png 300 _

* Telephone company
.image code/telephone_dec.png 300 _
.image code/telephone_dec_ans.png 150 _

* Telephone company
.image code/telephone_float.png 300 _

* Telephone company
.image code/telephone_float.png 300 _
.image code/telephone_float_ans1.png 150 _

* Decimal vs Floating point
.image img/Multiply_new.png 500 _

* Software vs Hardware
.image img/Multiply_new2.png 500 _

* Not all implementations of numbering systems are created equal

* 
.image img/8087.jpg 200 _

* Binary floating point Multiply
    func Mul(x, y float64) float64 {
        return x * y
    }

* Binary floating point Assembler
    func Mul(x, y float64) float64 {
        return x * y
    }
 
    "".Mul STEXT nosplit size=23 args=0x18 locals=0x0
    TEXT	"".Mul(SB), NOSPLIT|ABIInternal, $0-24
    FUNCDATA	$0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
    FUNCDATA	$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
    FUNCDATA	$2, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
    PCDATA	$0, $0
    PCDATA	$1, $0
    MOVSD	"".x+8(SP), X0
    MOVSD	"".y+16(SP), X1
    MULSD	X1, X0
    MOVSD	X0, "".~r2+24(SP)
    RET

* Decimal Arithmetic in Go
    // Mul computes d * e
    func (ctx Context64) Mul(d, e Decimal64) Decimal64 {
        dp := d.getParts()
        ep := e.getParts()
        if dec := propagateNan(&dp, &ep); dec != nil {
            return *dec
        }
        var ans decParts
        ans.sign = dp.sign ^ ep.sign
        if dp.fl == flInf || ep.fl == flInf {
            if ep.isZero() || dp.isZero() {
                return QNaN64
            }
            return infinities[ans.sign]
        }
        if ep.significand.lo == 0 || dp.significand.lo == 0 {
            return zeroes[ans.sign]
        }
        var roundStatus discardedDigit
        significand := umul64(dp.significand.lo, ep.significand.lo)
        ans.exp = dp.exp + ep.exp + 15
        significand = significand.div64(decimal64Base)
        ans.significand.lo = significand.lo
        if ans.exp >= -expOffset {
            ans.exp, ans.significand.lo = renormalize(ans.exp, ans.significand.lo)
        } else if ans.exp < 1-expMax {
            roundStatus = ans.rescale(-expOffset)
        }
        ans.significand.lo = ctx.roundingMode.round(ans.significand.lo, roundStatus)
        if ans.significand.lo > maxSig || ans.exp > expMax {
            return infinities[ans.sign]
        }
        return newFromParts(ans.sign, ans.exp, ans.significand.lo)
    }

* Decimal Arithmetic in Assembler
.code ../examples/MulDec.asm

* Decimal Arithmetic in Assembler
.code ../examples/MulDec.asm  /^// PT 2/,/// PT 3/

* Decimal Arithmetic in Assembler
.code ../examples/MulDec.asm  /^// PT 3/,/// PT 4/

* Decimal Arithmetic in Assembler
.code ../examples/MulDec.asm  /^// PT 4/,

* Looking forward
- More optimisation
- Implement 128 bit
- Assembler optimisations

* Another Decimal library
.link http://www.github.com/anz-bank/decimal


