Go for Decimals
Tags: decimal, floating point, fixed precision, IEEE 754R

Joshua Carpeggiani
Software Engineer, ANZ
joshua.carpeggiani@anz.com

* 
.image img/Patriot_missile.jpg

* Floating point numbers
.play ../examples/floatExample.go /^func main/,/^}/

: TODO redo this one
* Floating point numbers
    a:= 0.1; b:= 0.2; c:= 0.3
    fmt.Println(a + b == c) // Evaluates to false

    d:= 0.6; e:= 0.2; f:= 0.8
    fmt.Println(d + e == f) // Evaluates to true

    math.Round(0.49999999999999999) // rounds to 1

* Floating point numbers
.play ../examples/TimeRounding.go /^func main/,/^}/




* Why
Not all numbering systems are created equal

* Binary 
 
.html html/binary_examples.html

* Binary 
 
.html html/binary_examples2.html

* Why?
.image img/BinDec.png _ 500

* Another Decimal library
.link http://www.github.com/anz-bank/decimal

- Project Goal: Implement a 64 & 128 bit decimal floating point library
- Conform as closely to ieee 754-2008 standard as practical

* Another Decimal library
.play ../examples/decimal/decimalExample.go /^func main/,/^}/

* Software vs Hardware
.image img/Add_new.png 500 _

* Decimal vs Floating point
.image img/Add_dec.png 500 _

* Why Not?
Not all implementations of numbering systems are created equal

* Binary floating point Add
    func Mul(x, y float64) float64 {
            return x * y
        }

* Binary floating point Assembler
    func Mul(x, y float64) float64 {
        return x * y
    }
 
    "".Mul STEXT nosplit size=23 args=0x18 locals=0x0
    TEXT	"".Mul(SB), NOSPLIT|ABIInternal, $0-24
    FUNCDATA	$0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
    FUNCDATA	$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
    FUNCDATA	$2, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
    PCDATA	$0, $0
    PCDATA	$1, $0
    MOVSD	"".x+8(SP), X0
    MOVSD	"".y+16(SP), X1
    MULSD	X1, X0
    MOVSD	X0, "".~r2+24(SP)
    RET

* Decimal Arithmetic in Go
    // Mul computes d * e
    func (ctx Context64) Mul(d, e Decimal64) Decimal64 {
        dp := d.getParts()
        ep := e.getParts()
        if dec := propagateNan(&dp, &ep); dec != nil {
            return *dec
        }
        var ans decParts
        ans.sign = dp.sign ^ ep.sign
        if dp.fl == flInf || ep.fl == flInf {
            if ep.isZero() || dp.isZero() {
                return QNaN64
            }
            return infinities[ans.sign]
        }
        if ep.significand.lo == 0 || dp.significand.lo == 0 {
            return zeroes[ans.sign]
        }
        var roundStatus discardedDigit
        significand := umul64(dp.significand.lo, ep.significand.lo)
        ans.exp = dp.exp + ep.exp + 15
        significand = significand.div64(decimal64Base)
        ans.significand.lo = significand.lo
        if ans.exp >= -expOffset {
            ans.exp, ans.significand.lo = renormalize(ans.exp, ans.significand.lo)
        } else if ans.exp < 1-expMax {
            roundStatus = ans.rescale(-expOffset)
        }
        ans.significand.lo = ctx.roundingMode.round(ans.significand.lo, roundStatus)
        if ans.significand.lo > maxSig || ans.exp > expMax {
            return infinities[ans.sign]
        }
        return newFromParts(ans.sign, ans.exp, ans.significand.lo)
    }

* Decimal Arithmetic in Assembler
.code ../examples/MulDec.asm

* Decimal Arithmetic in Assembler
.code ../examples/MulDec.asm  /^// PT 2/,/// PT 3/

* Decimal Arithmetic in Assembler
.code ../examples/MulDec.asm  /^// PT 3/,/// PT 4/

* Decimal Arithmetic in Assembler
.code ../examples/MulDec.asm  /^// PT 4/,

* Requirements of a number library: Decimal floats
1. Accuracy ✓
2. Portability ✓
3. Speed ✗ (not yet)

* Looking forward
- More optimisation
- Implement 128 and 64 bit
- Assembler optimisations

* Another Decimal library
.link http://www.github.com/anz-bank/decimal


