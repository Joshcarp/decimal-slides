Go for Decimals
Tags: decimal, floating point, fixed precision, IEEE 754R

Joshua Carpeggiani
Software Engineer, ANZ
joshua.carpeggiani@anz.com

* 
.image img/Patriot_missile.jpg

* Floating point numbers
.play ../examples/TimeRounding.go /^func main/,/^}/

: TODO redo this one
* Floating point numbers
    a:= 0.1; b:= 0.2; c:= 0.3
    fmt.Println(a + b == c) // Evaluates to false

    d:= 0.6; e:= 0.2; f:= 0.8
    fmt.Println(d + e == f) // Evaluates to true

    math.Round(0.49999999999999999) // rounds to 1


* Why
Not all numbering systems are created equal

* Binary 
 
.html html/binary_examples.html

* Binary 
 
.html html/binary_examples2.html

* Why?
.image img/BinDec.png _ 500

* Another Decimal library
.link http://www.github.com/anz-bank/decimal

- Project Goal: Implement a 64 & 128 bit decimal floating point library
- Conform as closely to ieee 754-2008 standard as practical

* Another Decimal library
.play ../examples/decimal/decimalExample.go /^func main/,/^}/

* Software vs Hardware
.image img/Add_new.png 500 _

* Decimal vs Floating point
.image img/Add_dec.png 500 _

* Why Not?
Not all implementations of numbering systems are created equal

* Binary floating point Add
    func Add(x, y float64) float64 {
            return x + y
        }

* Binary floating point Assembler
    func Add(x, y float64) float64 {
        return x + y
    }
 
    "".Add STEXT nosplit size=23 args=0x18 locals=0x0
    TEXT    "".Add(SB), NOSPLIT|ABIInternal, $0-24
    FUNCDATA    $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
    FUNCDATA    $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
    FUNCDATA    $3, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
    PCDATA    $2, $0
    PCDATA    $0, $0
    MOVSD    "".x+8(SP), X0
    MOVSD    "".y+16(SP), X1
    ADDSD    X1, X0
    MOVSD    X0, "".~r2+24(SP)
    RET

* Decimal Arithmetic in Go
    func (d Decimal64) Add(e Decimal64) Decimal64 {
        dp := d.getParts()
        ep := e.getParts()
        if dec := propagateNan(&dp, &ep); dec != nil {
            return *dec
        }
        if dp.fl == flInf || ep.fl == flInf {
            // Check infinities
        }
        // ...
        // Match scales
        var rndStatus discardedDigit
        dp.matchScales128(&ep)
        ans := dp.add128(&ep)
        rndStatus = ans.roundToLo()
        if ans.exp < -expOffset {
            rndStatus = ans.rescale(-expOffset)
        }
        // Do the calculation ...
        ans.significand.lo = ctx.roundingMode.round(ans.significand.lo, rndStatus)
        if ans.exp >= -expOffset && ans.significand.lo != 0 {
            ans.exp, ans.significand.lo = renormalize(ans.exp, ans.significand.lo)
        }
        if ans.exp > expMax || ans.significand.lo > maxSig {
            return infinities[ans.sign]
        }
        return newFromParts(ans.sign, ans.exp, ans.significand.lo)
    }

* Decimal Arithmetic in Assembler
.code ../examples/AddDec.asm

* Decimal Arithmetic in Assembler
.code ../examples/AddDec.asm  /^// PT 2/,/// PT 3/

* Decimal Arithmetic in Assembler
.code ../examples/AddDec.asm  /^// PT 3/,

* Requirements of a number library: Decimal floats
1. Accuracy ✓
2. Portability ✓
3. Speed ✗ (not yet)

* Looking forward
- More optimisation
- Implement 128 and 64 bit
- Assembler optimisations

* Another Decimal library
.link http://www.github.com/anz-bank/decimal


