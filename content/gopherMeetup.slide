Go for Decimals
Tags: decimal, floating point, fixed precision, ieee 754R

Joshua Carpeggiani
Software Engineer, ANZ*
joshua.carpeggiani@anz.com

: Another Decimal Library
: Open source project started by senior guy at anz without much time
: Enter Josh
: Started with go in December 2018
: First time working on Go and open source
* Usage of decimal libraries
.image img/decimalSurvey.png 600 _
* Correctness

* Floating point numbers
.html html/floatingpointbits.html
.code ../examples/floatExample.go /^func main/,/^}/
- floats aren't sufficient

* Scientific notation

.html html/basic.html

* Binary floating point numbers
.html html/basicBinary.html
: This number is equal to 9.3125

* Floating point arithmetic
- “Decoding” isn’t really needed

.html html/floatingPointDecoding.html
- Number of exponent is the same as the number of shifting places

* Floating point arithmetic
- “Decoding” isn’t really needed
.html html/floatingPointDecoding2.html
.play ../examples/bitshifts.go /^func main/,/^}/


* The problem with floating point numbers
Repeated decimal numbers:
.html html/110.html
Repeated binary numbers:
.html html/decFrac.html

* Why?
.html html/Sheet2.html
* Why?
.image img/BinDec.png _ 500
* When does this matter?

- Compounding errors
- Need for exact numbers

.play ../examples/TimeRounding.go /^func main/,/^}/


* Solution - Decimal datatype
.html html/110decimal.html

.play ../examples/decimalExample.go /^func main/,/^}/
Base 10 counting system instead of base 2

* Existing Go decimal datatypes
.link https://github.com/ericlagergren/decimal/ github.com/ericlagergren/decimal
.link https://github.com/cockroachdb/apd github.com/cockroachdb/apd
.link https://github.com/shopspring/decimal github.com/shopspring/decimal
shopspring seems to be unsupported; last commit was June 2018

* 'Arbitrary precision' decimals
'Big Decimals'
- Based on big.int
- Allows for arbitrary precision

.code ../examples/bigDecimal.go  /^type Decimal struct/,/^}/

.code ../examples/bigInt.go /(?s)type Int struct {(.*)/

: “Big decimals” and how they work (really just listing these points)
: math/big → slice of bytes and does calculations from there
: Other implementations are based on big ints, which are
: Decimal(type big int) → nat → []word (type uint) (2 pointers)
: This is fundamentally slower, and takes up more space, even for an empty decimal
: Arithmetic needs to access slices, then calculate, then write to slice
- Walking pointers is inherently going to be slower

* Another Decimal library
.link http://www.github.com/anz-bank/decimal

- Project Goal: Implement a 64 & 128 bit decimal floating point library
- Conform as closely to ieee 754-2008 standard as practical

: I came on board in december, and it was my first go project
: The library already had quite a substantial code base

* A decimal type optimized for performance
.code ../examples/decimal.go /^type Decimal64 struct/,/^}/
- Fast by intention, altough can only represent a max value of 999999999999999*10^384
- Unlike big decimal which can represent arbitrarily large numbers

: What would a go “style” decimal look like?
: Elegant and self contained, only making use of essential math/bits packages
: Simple uint64 type (decimal 128 type coming too)
: This simplifies a lot of arithmetic, makes encoding and decoding simple and fast and is suitable for many use cases

* Bit representation of ieee 754-2008 decimal floating point
.html html/decimalpointbits.html
pros:
- small footprint within single uint64
- nice and clean
- no pointers 
cons:
- No arbitrary precision

* Benchmarking
Testing
- IBM test suite online with _81,300_ test cases
.link http://speleotrove.com/decimal/
Note: these benchmarks are testing edgecases

* Benchmarking

- float64
- anz-bank/decimal
- shopspring/decimal
- ericlagergren/decimal
Benchmarks are located at
.link https://github.com/joshcarp/decimal-slides

* Benchmark Abs
- lower is better

.image img/Abs.png 500 _

* Benchmark Multiply
- lower is better

.image img/Multiply.png 500 _

* Benchmark Divide
- lower is better

.image img/Divide.png 500 _

* Benchmark Add
- lower is better

.image img/Add.png 500 _


* Why?
- Slower than expected
- Theory: Maybe encoding/decoding has slowed it down
* Encoding/Decoding a decimal floating point number
.code ../examples/decParts.go  /START OMIT/,/END OMIT/

- starting to look a little like Big decimals ...
* Why?
.code ../examples/ansFunction.go /START OMIT/,/END OMIT/
- first thing we need to do is encode, last thing we do is decode
* Why?
.html html/decimalpointbits.html

Expands 

.html html/decExpanded.html


* Benchmarks v2
- removing the encoding and decoding; only use struct

* Benchmark Abs

.image img/Abs_optimised_1.png 500 _

* Benchmark Multiply

.image img/Multiply_optimised_1.png 500 _

* Benchmark Divide

.image img/Divide_optimised_1.png 500 _

* Benchmark Add

.image img/Add_optimised_1.png 500 _

* ericlagergren Big decimal
.code ../examples/ericDecimal.go /START OMIT/,/END OMIT/
- combines the speed of fixed precision and the accuracy of arbitrary precision
- doesn't actually pass around any structs
 
  func (c Context) Add(z, x, y *Big) *Big { 

* Even more optimisation
- use pointers to everything; never actually pass structs

.image img/Add_optimised_2.png 500 _

* Decimal comparisons

.html html/comparison.html

* In the future
- Need to optimise more
- More benchmarking + Cross platorm
- A good, well supported decimal would boost adoption in financial sector
- join the fun: github.com/anz-bank/decimal
: We’d love for decimal to be part of the go core, might also boost adoption in the finance sector
: Show an application of anz-bank decimal, and how code would be a lot more elegant with operator overloading and such
*   (overloading)
.code ../examples/overloading.go /START OMIT/,/END OMIT/

* Links
- Graphics adapted fromfrom
.link https://ciechanow.ski/exposing-floating-point/

- Benchmarking
.link https://github.com/joshcarp/decimal-slides
- Github
.link https://github.com/anz-bank/decimal

- Survey from reddit user kardianos